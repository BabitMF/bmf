/** \page BasicConcepts 架构及特性

## 整体架构

框架层包括如下主要组件：

- 接口层：提供框架的对外接口，目前支持C++、python、go 3套接口，开发者可以调用BMF接口构建视频处理应用
- 引擎层：引擎层是BMF的核心，主要包含Graph Builder和Graph Engine，Builder负责视频处理pipeline的搭建，Engine负责pipeline的执行
- 模块开发SDK：引擎层之下，BMF提供3套模块开发SDK，和接口层一样，也支持使用C++、python、go 3种语言来开发模块，且不同语言开发的模块可以完全自由的通过引擎层进行串联执行
- 服务层：为模块开发者提供模块注册和管理服务，所有操作流程通过可视化界面完成。每个模块有自己的版本、依赖，模块也可以依赖其他模块来构建更复杂的模块
- 命令行工具：和服务层配合工作，帮助开发者下载需要使用的模块，构建开发环境
- 调试工具集：包括了Graph可视化工具，运行时快照工具，性能分析工具等一系列工具

<img src="./images/arch.png" style="zoom:40%;" />

## 主要特性

### 多语言流式接口

BMF的Graph采用流式接口构建，下面的语句表示对一个视频进行解码，对于解码后的视频流再依次进行scale、crop操作，然后再编码成一个文件。

```
graph.decode()['video'].scale().crop().encode()
```

BMF支持C++、Python、Go 3套接口，接口参数和代码风格都完全一致。

### 松耦合高度可适配模块

模块是BMF内部最小执行单位，每个模块完成视频处理的一个步骤，如解码、编码等，模块支持多输入多输出，每一路输入/输出称为一路Stream。模块间传输的数据称为Packet，Packet支持任意数据类型。

对于模块，我们定义了非常简单的对外接口，主要的几个如下：

- init：模块初始化
- process：模块进行一次处理
- reset：模块重新配置
- close：模块关闭

对于使用者来讲，开发一个模块只需要实现上述几个函数就可以。

### 多种执行模式

BMF提供了丰富的模块资源，流式接口提供了简洁灵活的搭建Graph的方式，而执行模式则提供了多种Graph运行的方式，适用于不同的应用场景。本节介绍其中比较主要的几种

- 普通模式

普通模式的流程首先调用builder接口搭建graph，然后执行graph，graph会全速执行直到结束，最后关闭graph。普通模式的典型应用场景如视频转码，输入一个或多个源视频文件，输出转码后的视频文件。

- Server模式

Graph的搭建在主线程完成，然后使Graph运行于Server模式，在这种模式下，Graph运行后处于等待任务的状态，任务则通过其他线程提交到Graph，任务的返回是同步的，支持多线程任务提交。

Server模式的特点是Graph创建和初始化一次，可以执行多个任务，这就避免了重复初始化带来的开销。这对于视频分析场景是比较有用的，因为往往模型加载会耗费比较长的时间。当然这种「初始化一次」的方式也会带来一些限制，就是Graph的结构不能变化，即所有提交的任务的处理方式必须一致。

- 预创建模式

为了解决Server模式「Graph结构初始化以后不能改变」的问题，BMF又提供了「预创建模式」，首先创建一些初始化开销比较大的模块，在执行任务时，使用这些预创建出来的模块搭建Graph，执行，然后关闭Graph，注意关闭Graph的时候不会释放预创建的模块，新的任务仍然可以使用这些预创建模块，这样同样达到了初始化一次执行多个任务的目的。

模块预创建模式的优点是避免初始化开销大的模块重复创建，同时又支持不同任务构建不同Graph，但其同样有一些限制，就是同时只能执行一个任务，不能把任务A和任务B放在两个线程里同时执行。

- 生成器模式

生成器模式是指BMF graph可以返回一个packet的生成器，开发者可以使用这个生成器做后续的处理，这种模式主要用于部分处理使用BMF的情况。

- 同步模式

在BMF engine内部，会有一些节点和任务调度的线程，对于视频的处理，这些线程主要保证了整个pipeline的并行处理，但是对于如图片处理这种单帧的场景，调度线程反而会带来一些overhead，因此对于这种场景，BMF提供了同步模式，即所有的模块处理都在主线程中串行执行，以达到更好的性能。

### 灵活的并行调度

对于一个BMF graph，我们可以对节点进行任意分组，放进不同的执行线程，实现并行执行。这种方式相比于每个模块单独一个线程执行，或者Filter graph的单线程执行要更加灵活。比如：对于一个既有CPU模块，又有GPU模块的Graph，我们可以把GPU模块放入一个执行线程，CPU模块放入另一个执行线程，或者根据实际计算量进行更加精细的拆分。我们实际业务中，还会有一条Graph用到多张GPU卡的情况，不同GPU卡的模块也可以拆分到不同的执行线程。

### 动态Graph

相对初始阶段构建好固定的Graph去运行，BMF还支持在运行过程中动态的改变Graph。主要包括：

- 在现有Graph当中任意增删节点
- 动态配置节点，即时生效

该特性的一个典型的应用场景是实时处理的场景比如视频会议，在会议过程中，有可能会有不同的新加入的用户以及离开会议的用户，每一个用户可以是被单独节点或者分支支撑着，通过在原有Graph中动态的增加或者删除这些节点就能很容易满足这样的实时处理的需求。

### 完全兼容FFmpeg

BMF另外一个特点是对FFmpeg的完全兼容，BMF包含了若干内置模块，这些内置模块对FFmpeg接口进行了封装，尤其是对于Filter graph部分的封装，除了完全兼容FFmpeg丰富的filter资源，而且可以在一个Graph里串联任意多个Filter graph，这就完全解决了上文提到的Filter Graph单线程执行的性能问题以及静态编译的功能扩展问题。另外每个ffmpeg filter既可以作为一个单独的模块使用，也可以搭建一个filter graph，把整体作为一个模块使用。
