"""
TODO: Add the script header information here.
Example: A custom BMF module generated by the BMF Module Template Generator.
"""

import argparse
import json
import os
import sys

import bmf
from bmf import (
    Module,
    Log,
    LogLevel,
    InputType,
    ProcessResult,
    Packet,
    Timestamp,
    VideoFrame,
    AudioFrame,
)
import bmf.hmp as mp

# TODO: Add dependencies including local imports and third party pip packages here.

class MyModule(Module):
    def __init__(self, node=None, option=None):
        Log.log(LogLevel.INFO, "MyModule module option: ", option)
        self._node = node
        self._option = option
        self._debug = option.get("debug", False)
        self._version = self.get_version()
        self._eof_received = {}

        # TODO: Add custom initialisation logic here.

    def process(self, task):
        for input_id, input_stream in task.get_inputs().items():
            output_stream = task.get_outputs()[input_id]
            while not input_stream.empty():
                pkt = input_stream.get()

                if pkt.timestamp == Timestamp.EOF:
                    Log.log_node(LogLevel.INFO, task.get_node(), f"Stream {input_id} - Received EOF")
                    self._eof_received[input_id] = True
                    output_stream.put(Packet.generate_eof_packet())
                    continue

                output_stream.put(pkt) # passthrough
                
                # TODO: Add per-frame packet processing logic here.

        if all(self._eof_received.get(input_id, False) for input_id in task.get_inputs()):
            # TODO: Add additional EOF processing logic here.
            task.timestamp = Timestamp.DONE
            return ProcessResult.OK

        return ProcessResult.OK

    def get_version(self):
        return "0.0.1"

def run_bmf_graph(
    input_path,
    output_path,
    custom_module_options=None,
    custom_video_params=None,
    custom_audio_params=None
):
    module_info = {
        "name": "my_module",
        "path": os.path.abspath(__file__),
        "entry": "my_module.MyModule"
    }

    module_options = {}

    if custom_module_options is not None:
        module_options.update(custom_module_options)

    graph = bmf.graph()
    streams = graph.decode({"input_path": input_path})
    processed_streams = bmf.module(
        [streams["video"], streams["audio"]],
        module_info,
        module_options
    )

    video_params = {
        "codec": "h264",
        # TODO: Add extra encoder video params if necessary.
    }
    audio_params = {
        "codec": "aac",
        # TODO: Add extra encoder audio params if necessary.
    }

    if custom_video_params is not None:
        video_params.update(custom_video_params)
    if custom_audio_params is not None:
        audio_params.update(custom_audio_params)

    bmf.encode(
        processed_streams[0], # video stream
        processed_streams[1], # audio stream
        {
            "output_path": output_path,
            "video_params": video_params,
            "audio_params": audio_params
        }
    ).run()

def main():
    parser = argparse.ArgumentParser(
        description='Run my_module to process an input video file',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Register arguments
    parser.add_argument('-i', '--input', required=True, help='Path to the input file')
    parser.add_argument('-o', '--output', required=False, default="output.mp4", help='Path to the input video file')
    parser.add_argument('-c', '--config', required=False, default=None, help='Path to the BMF module options JSON file')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose output')
    
    args = parser.parse_args()

    input_path = args.input
    config_path = args.config
    
    # Check the input video file exists
    if not os.path.isfile(input_path):
        print(f"Error: Video file not found: {input_path}")
        sys.exit(1)
    
    # Check the config file exists if given
    if config_path and not os.path.isfile(config_path):
        print(f"Error: Config file not found: {config_path}")
        sys.exit(1)

    # Check video file extension (basic validation)
    valid_video_extensions = ['.mp4', '.avi', '.mov', '.mkv']
    if not any(input_path.lower().endswith(ext) for ext in valid_video_extensions):
        print(f"Warning: File {input_path} may not be a valid video file.")
    
    # Load config
    if config_path:
        try:
            with open(config_path, 'r') as f:
                config = json.load(f)
        except json.JSONDecodeError:
            print(f"Error: Config file is not a valid JSON: {config_path}")
            sys.exit(1)
    else:
        config = {}
    
    # Process the video according to the configuration
    output_path = args.output
    verbose = args.verbose
    
    if verbose:
        print(f"Processing video: {input_path}")
        print(f"Using configuration: {json.dumps(config, indent=2)}")
        print(f"Output will be saved to: {output_path}")
    
    run_bmf_graph(
        input_path,
        output_path,
        config,
    )
    
    print(f"Video processing complete. Output saved to {output_path}")

if __name__ == "__main__":
    main()